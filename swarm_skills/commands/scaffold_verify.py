from __future__ import annotations

import os
import re
import shlex
import signal
import socket
import subprocess
import time
from pathlib import Path
from typing import Any
from urllib.error import URLError
from urllib.request import urlopen

from swarm_skills.catalog import resolve_template
from swarm_skills.runtime import SkillRun, run_command, write_json


def _wait_for_health(url: str, timeout_sec: int) -> tuple[bool, str]:
    deadline = time.time() + timeout_sec
    last_error = ""
    while time.time() < deadline:
        try:
            with urlopen(url, timeout=1.5) as response:  # nosec B310
                body = response.read().decode("utf-8")
                if 200 <= response.status < 300:
                    return True, body
                last_error = f"HTTP {response.status}: {body}"
        except URLError as exc:
            last_error = str(exc)
        except TimeoutError as exc:
            last_error = str(exc)
        time.sleep(0.5)
    return False, last_error


def _copy_or_generate_env_example(template_dir: Path, target_path: Path, fallback_env: list[str]) -> None:
    source_env = template_dir / ".env.example"
    target_path.parent.mkdir(parents=True, exist_ok=True)
    if source_env.exists():
        target_path.write_text(source_env.read_text(encoding="utf-8"), encoding="utf-8")
        return

    lines = ["# Generated by scaffold_verify"]
    if fallback_env:
        for item in fallback_env:
            lines.append(f"{item}=")
    else:
        lines.append("PORT=3000")
    target_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def _resolve_port(port_arg: str | None, default_port: int) -> int:
    if port_arg is None:
        return default_port
    if str(port_arg).strip().lower() in {"auto", "0"}:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.bind(("127.0.0.1", 0))
                return int(sock.getsockname()[1])
        except OSError:
            return default_port
    return int(str(port_arg))


def _resolve_strategies(template: Any) -> list[str]:
    declared = template.boot.get("health_strategy")
    if isinstance(declared, list) and declared:
        return [str(item) for item in declared]
    health_path = str(template.boot.get("health_path", "/api/health"))
    return [f"http_get:{health_path}"]


def run(args: Any) -> int:
    workspace_root = Path(args.workspace_root).resolve()
    skill_run = SkillRun(skill="scaffold_verify", workspace_root=workspace_root)

    try:
        template = resolve_template(args.template, workspace_root)
    except FileNotFoundError as exc:
        skill_run.add_note(str(exc))
        return skill_run.finalize("fail", emit_json=args.json)

    smoke: dict[str, Any] = {
        "commands": [],
        "health_checks": [],
        "template": {
            "id": template.id,
            "path": str(template.path.relative_to(workspace_root)),
            "status": template.status,
            "version": template.version,
        },
    }

    for command in template.boot.get("preflight", []):
        result = run_command(command, cwd=template.path)
        smoke["commands"].append(
            {
                "cmd": result.cmd,
                "cwd": result.cwd,
                "exit_code": result.exit_code,
                "stderr": result.stderr,
                "stdout": result.stdout,
            }
        )
        if result.exit_code != 0:
            skill_run.add_note(f"Preflight command failed: {' '.join(command)}")
            smoke_path = skill_run.run_dir / "smoke.json"
            write_json(smoke_path, smoke)
            skill_run.record_artifact(smoke_path)
            return skill_run.finalize(
                "fail",
                emit_json=args.json,
                provenance={"template_id": template.id, "template_version": template.version},
            )

    boot_cmd = template.boot.get("command")
    if template.status != "active" or not isinstance(boot_cmd, list) or not boot_cmd:
        skill_run.add_note(
            "Template is not bootable yet (status is not active or boot.command is missing)."
        )
        smoke["health_checks"].append(
            {
                "strategy": "boot",
                "ok": False,
                "detail": "boot skipped",
            }
        )
        smoke_path = skill_run.run_dir / "smoke.json"
        write_json(smoke_path, smoke)
        skill_run.record_artifact(smoke_path)

        compat_bootstrap_dir = workspace_root / "artifacts" / "bootstrap"
        compat_bootstrap_dir.mkdir(parents=True, exist_ok=True)
        compat_smoke = compat_bootstrap_dir / "smoke.json"
        write_json(compat_smoke, smoke)
        skill_run.record_artifact(compat_smoke)

        env_path = skill_run.run_dir / "env.example"
        _copy_or_generate_env_example(
            template.path,
            env_path,
            list(template.runbook.get("env", [])),
        )
        skill_run.record_artifact(env_path)
        compat_env_path = compat_bootstrap_dir / "env.example"
        _copy_or_generate_env_example(
            template.path,
            compat_env_path,
            list(template.runbook.get("env", [])),
        )
        skill_run.record_artifact(compat_env_path)
        return skill_run.finalize(
            "fail",
            emit_json=args.json,
            provenance={"template_id": template.id, "template_version": template.version},
        )

    default_port = int(template.boot.get("default_port", 3210))
    port = _resolve_port(args.port, default_port)
    env = os.environ.copy()
    env["PORT"] = str(port)

    process = subprocess.Popen(
        boot_cmd,
        cwd=str(template.path),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        env=env,
    )

    smoke["commands"].append(
        {
            "cmd": boot_cmd,
            "cwd": str(template.path),
            "exit_code": None,
            "stdout": "",
            "stderr": "",
            "note": "boot command started as background process",
            "port": port,
        }
    )

    strategies = _resolve_strategies(template)
    strategy_results: list[dict[str, Any]] = []

    early_exit = False
    time.sleep(0.25)
    if process.poll() is not None and process.returncode not in (0, -15):
        early_exit = True

    for strategy in strategies:
        if strategy.startswith("http_get:"):
            path = strategy.split(":", 1)[1].strip() or "/api/health"
            url = f"http://127.0.0.1:{port}{path}"
            ok, detail = _wait_for_health(url, timeout_sec=args.health_timeout_sec)
            strategy_results.append(
                {
                    "strategy": strategy,
                    "ok": ok,
                    "detail": detail[:500],
                    "url": url,
                }
            )
            continue

        if strategy.startswith("test_cmd:"):
            cmd_text = strategy.split(":", 1)[1].strip()
            cmd = shlex.split(cmd_text)
            result = run_command(cmd, cwd=template.path, timeout_sec=90)
            strategy_results.append(
                {
                    "strategy": strategy,
                    "ok": result.exit_code == 0,
                    "detail": f"exit_code={result.exit_code}",
                    "stdout": result.stdout[-700:],
                    "stderr": result.stderr[-700:],
                }
            )
            continue

        if strategy.startswith("process_stdout_regex:"):
            pattern = strategy.split(":", 1)[1]
            strategy_results.append(
                {
                    "strategy": strategy,
                    "ok": None,
                    "detail": f"deferred-regex:{pattern}",
                }
            )
            continue

        strategy_results.append(
            {
                "strategy": strategy,
                "ok": False,
                "detail": "unknown strategy prefix",
            }
        )

    if process.poll() is None:
        process.send_signal(signal.SIGTERM)
        try:
            process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            process.kill()
            process.wait(timeout=5)

    stdout, stderr = process.communicate(timeout=1)
    smoke["commands"][-1]["exit_code"] = process.returncode
    smoke["commands"][-1]["stdout"] = stdout[-2500:]
    smoke["commands"][-1]["stderr"] = stderr[-2500:]

    for row in strategy_results:
        if row.get("ok") is None and row["strategy"].startswith("process_stdout_regex:"):
            pattern = row["strategy"].split(":", 1)[1]
            matched = re.search(pattern, stdout + "\n" + stderr) is not None
            row["ok"] = matched
            row["detail"] = f"regex={'matched' if matched else 'not-matched'}"

    smoke["health_checks"] = strategy_results
    smoke["early_exit"] = early_exit

    any_ok = any(bool(row.get("ok")) for row in strategy_results)
    if early_exit and not any_ok:
        skill_run.add_note("Boot process exited early and no health strategy succeeded.")
    elif any_ok:
        skill_run.add_note("At least one declared health strategy succeeded.")
    else:
        skill_run.add_note("No declared health strategy succeeded.")

    smoke_path = skill_run.run_dir / "smoke.json"
    write_json(smoke_path, smoke)
    skill_run.record_artifact(smoke_path)

    env_path = skill_run.run_dir / "env.example"
    _copy_or_generate_env_example(template.path, env_path, list(template.runbook.get("env", [])))
    skill_run.record_artifact(env_path)

    compat_bootstrap_dir = workspace_root / "artifacts" / "bootstrap"
    compat_bootstrap_dir.mkdir(parents=True, exist_ok=True)
    compat_smoke_path = compat_bootstrap_dir / "smoke.json"
    write_json(compat_smoke_path, smoke)
    skill_run.record_artifact(compat_smoke_path)

    compat_env_path = compat_bootstrap_dir / "env.example"
    _copy_or_generate_env_example(template.path, compat_env_path, list(template.runbook.get("env", [])))
    skill_run.record_artifact(compat_env_path)

    status = "pass" if any_ok else "fail"
    return skill_run.finalize(
        status,
        emit_json=args.json,
        provenance={"template_id": template.id, "template_version": template.version},
    )
